<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















  

<link href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Backend Developer">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="LongYuBo&#39;s Blog">
<meta property="og:url" content="https://blog.longyubo.com/index.html">
<meta property="og:site_name" content="LongYuBo&#39;s Blog">
<meta property="og:description" content="Backend Developer">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LongYuBo&#39;s Blog">
<meta name="twitter:description" content="Backend Developer">






  <link rel="canonical" href="https://blog.longyubo.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LongYuBo's Blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?25fe09f36abdb49c8a59617c513bf785";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LongYuBo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Things about programming</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.longyubo.com/2018/10/12/cardinality_estimation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LongYuBo">
      <meta itemprop="description" content="Backend Developer">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LongYuBo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/cardinality_estimation/" itemprop="url">
                  基数估计算法简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-12 21:40:00 / 修改时间：22:42:28" itemprop="dateCreated datePublished" datetime="2018-10-12T21:40:00+08:00">2018-10-12</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/12/cardinality_estimation/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/10/12/cardinality_estimation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基数估计算法简介"><a href="#基数估计算法简介" class="headerlink" title="基数估计算法简介"></a>基数估计算法简介</h2><p>注：本文是之前工作时在团队内分享的一个PPT的文字版本.</p>
<p>下文中的sqrt表示开根号(sqrt(4)=2)，m^n表示m的n次方</p>
<h3 id="什么是基数（Cardinality）"><a href="#什么是基数（Cardinality）" class="headerlink" title="什么是基数（Cardinality）"></a>什么是基数（Cardinality）</h3><p>基数指的是一个可重复集合中不重复元素的个数。</p>
<h3 id="什么是基数计算"><a href="#什么是基数计算" class="headerlink" title="什么是基数计算"></a>什么是基数计算</h3><p>给定一个含有重复元素的有限集合，计算其不重复元素的个数。</p>
<p>应用场景举例:</p>
<ul>
<li>某家店铺今天有多少不同用户访问</li>
<li>某家店铺今天接待了多少不同买家</li>
</ul>
<p>简单来说就是各种UV的计算</p>
<p>常见的实现方式</p>
<p>Hash集合 + 计数 或者 BitMap + 计数</p>
<p>缺陷：占用空间过大</p>
<p>###什么是基数估计算法</p>
<p>基数估计是一类概率算法，可以在有一定误差的前提下以远低于精确计算的时间和空间消耗对基数进行估计</p>
<p>特点</p>
<ul>
<li>有误差</li>
<li>时间复杂度和空间复杂度仅与误差和基数上限有关</li>
<li>易于合并</li>
</ul>
<h3 id="有哪些基数估计算法"><a href="#有哪些基数估计算法" class="headerlink" title="有哪些基数估计算法"></a>有哪些基数估计算法</h3><ul>
<li>Linear Counting</li>
<li>LogLog Counting</li>
<li>Adaptive Counting</li>
<li>HyperLogLog Counting</li>
<li>HyperLogLog++ Counting</li>
</ul>
<p>它们之间的关系如下图所示：</p>
<p><img src="http://opui0kl1z.bkt.clouddn.com/counting_tree.png" alt=""></p>
<h2 id="Linear-Counting"><a href="#Linear-Counting" class="headerlink" title="Linear Counting"></a>Linear Counting</h2><p>Linear Counting是在1990年的一篇论文<br><a href="http://101.96.10.27/dblab.kaist.ac.kr/Prof/pdf/Whang1990(linear).pdf" target="_blank" rel="noopener">A linear-time probabilistic counting algorithm for database applications</a> 中被提出。</p>
<p>作为一个早期的基数估计算法，Linear Counting的空间复杂度方面与简单bitmap方法是一样的（但是有个常数项级别的降低，约1/10），都是O(N)。 因此很少单独使用。目前只在Adaptive Counting中被混合使用</p>
<p>特点：在基数较小时比较准确</p>
<p>具体算法如下:</p>
<p>设有一哈希函数H，其哈希结果空间有m个值，并且哈希结果服从均匀分布。</p>
<p>使用一个长度为m的bitmap，每个bit为一个桶，均初始化为0 </p>
<p>设一个集合的基数为n，此集合所有元素通过H哈希到bitmap中，如果某一个元素被哈希到第k个比特并且第k个比特为0，则将其置为1。</p>
<p>当集合所有元素哈希完成后，设bitmap中还有u个bit为0</p>
<p>估计值 n = -mLn(u/m)</p>
<p>误差 = (e^t-t-1)/2n 其中 t = n/m 也就是基数与哈希空间的比值</p>
<p>标准差 = (sqrt(m)*(e^t-t-1)^0.5)/n</p>
<p>误差控制，以标准差作为误差，记容许误差为E，则 m &gt; (e^t -t -1)/(E*t)^2</p>
<p>例子:</p>
<p>n=11(实际数目) m=8(哈希空间) u=2(0的个数)</p>
<p>估计值=-8*ln(0.25)=11.04</p>
<p><img src="http://opui0kl1z.bkt.clouddn.com/lc_example.png" alt=""></p>
<p>满桶控制:</p>
<p>如果m比n小太多，则很有可能所有桶都被哈希到了，此时u的值为0，估计公式就不起作用了（变成无穷大）。</p>
<p>因此m的选择除了要满足上面误差控制的需求外，还要保证满桶的概率非常小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m的选取应该遵从:</span><br><span class="line">m &gt; beta(e^t-t-1) 其中 beta=max(5,1/((E*t)^2))</span><br></pre></td></tr></table></figure>
<h2 id="LogLog-Counting"><a href="#LogLog-Counting" class="headerlink" title="LogLog Counting"></a>LogLog Counting</h2><p>LogLog Counting 出自论文<a href="http://algo.inria.fr/flajolet/Publications/DuFl03-LNCS.pdf" target="_blank" rel="noopener">Loglog Counting of Large Cardinalities</a></p>
<p>Loglog Counting的空间复杂度仅有O(log2(log2(Nmax)))，所以叫LogLog Counting</p>
<h3 id="算法前提"><a href="#算法前提" class="headerlink" title="算法前提"></a>算法前提</h3><p>均匀随机化:与LC一样，在使用LLC之前需要选取一个哈希函数H应用于所有元素，然后对哈希值进行基数估计。H必须满足如下条件</p>
<ul>
<li><p>H的结果具有很好的均匀性，无论原始集合元素的值分布如何，其哈希结果的值<b>几乎</b>服从均匀分布</p>
</li>
<li><p>H的碰撞几乎可以忽略不计。认为对于不同的原始值，其哈希结果相同的概率非常小以至于可以忽略不计。</p>
</li>
<li><p>H的哈希结果是固定长度的 </p>
</li>
</ul>
<h3 id="算法基本思路"><a href="#算法基本思路" class="headerlink" title="算法基本思路"></a>算法基本思路</h3><p>设a为待估集合（哈希后）中的一个元素，由上面对H的定义可知，a可以看做一个长度固定的比特串（也就是a的二进制表示）.</p>
<p>设H哈希后的结果长度为L比特，将这L个比特位从左到右分别编号为1、2、…、L：</p>
<p><img src="http://opui0kl1z.bkt.clouddn.com/loglog_hash.png" alt=""></p>
<p>又因为a是从服从均与分布的样本空间中随机抽取的一个样本，因此a每个比特位服从如下分布且相互独立。</p>
<p> P(x=k)=0.5 </p>
<p>就是a的每个比特位为0和1的概率各为0.5，且相互之间是独立的</p>
<p>设ρ(a)为a的比特串中第一个“1”出现的位置，显然1≤ρ(a)≤L，这里我们忽略比特串全为0的情况（概率为1/2^L）。如果我们遍历集合中所有元素的比特串，取ρmax 为所有ρ(a) 的最大值。</p>
<p>此时我们可以将2^ρmax 作为基数的一个粗糙估计，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n 约为 2^ρmax</span><br></pre></td></tr></table></figure>
<p>减小误差</p>
<ul>
<li>分桶平均</li>
<li>偏差修正</li>
</ul>
<p>分桶平均</p>
<p>将哈希空间平均分成m份，每份称之为一个桶</p>
<p>对于每一个元素，其哈希值的前k比特作为桶编号， 2^k = m</p>
<p>后L-k个比特作为真正用于基数估计的比特串</p>
<p>桶编号相同的元素被分配到同一个桶，在进行基数估计时，首先计算每个桶内元素最大的第一个“1”的位置，设为M[j]，然后对这m个值取平均后再进行估计</p>
<p><img src="http://opui0kl1z.bkt.clouddn.com/llc_math_mean_2.png" alt=""></p>
<p>误差修正:</p>
<p><img src="http://opui0kl1z.bkt.clouddn.com/llc_result.png" alt=""></p>
<p>误差分析<br>当m不太小（不小于64）时:</p>
<p>StdError = 1.30/sqrt(m) </p>
<p>误差控制:<br>在应用LLC时，主要需要考虑的是分桶数m，而这个m主要取决于误差。根据上面的误差分析，如果要将误差控制在E之内，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m &gt; (1.30/E)^2</span><br></pre></td></tr></table></figure></p>
<p>内存使用分析:</p>
<p>假设H的值为32bit，由于ρmax≤32，因此每个桶需要5bit空间存储这个桶的ρmax，m个桶就是5m/8字节。</p>
<p>例如基数上限为一亿（约2^27），当分桶数m为1024时，每个桶的基数上限约为2^27/2^10=2^17</p>
<p>因为每个桶需要5bit，需要字节数就是5×1024/8=640，误差为1.30/sqrt(1024)=0.040625，也就是约为4%。</p>
<p>LLC标准差是渐近组合计数，也就是说，随着n趋向于无穷大，标准差趋向于1.30/sqrt(m)，而不是说n多大时其值都一致为1.30/sqrt(m).</p>
<p>其无偏性也是渐近的，只有当n远远大于m时，其估计值才近似无偏。因此当n不太大时，LLC的效果并不好。</p>
<p>通过统计分析方法，我们可以得到n具体小到什么程度我们就不可忍受了，另外就是当n太小时可不可以用别的估计方法替代LLC来弥补LLC这个缺陷。Adaptive Counting 及HyperLogLog Counting都是基于这个思想实现的。</p>
<h2 id="Adaptive-Counting"><a href="#Adaptive-Counting" class="headerlink" title="Adaptive Counting"></a>Adaptive Counting</h2><p>Adaptive Counting在<a href="http://conferences.sigcomm.org/sigcomm/2005/paper-CaiPan.pdf" target="_blank" rel="noopener">Fast and accurate traffic matrix measurement using adaptive cardinality counting</a>中被提出。</p>
<p>Adaptive Counting只是简单将LC和LLC组合使用，根据基数量级决定是使用LC还是LLC。具体是通过分析两者的标准差，给出一个阈值，根据阈值选择使用哪种估计。</p>
<p>特点：在基数较大时比较准确</p>
<p>分析一下LC和LLC的存储结构，可以发现两者是兼容的，区别仅仅在于LLC关心每个桶的ρmax，而LC仅关心此桶是否为空。因此只要简单认为ρmax值不为0的桶为非空，0为空就可以使用LLC的数据结构做LC估计了。 </p>
<p>联立linear counting和loglog Counting的误差<br><img src="http://opui0kl1z.bkt.clouddn.com/lc_se.png" alt=""><br><img src="http://opui0kl1z.bkt.clouddn.com/llc_se.png" alt=""><br><img src="http://opui0kl1z.bkt.clouddn.com/adaptive_counting.png" alt=""></p>
<h2 id="HyperLogLog-Counting"><a href="#HyperLogLog-Counting" class="headerlink" title="HyperLogLog Counting"></a>HyperLogLog Counting</h2><p>HyperLogLog Counting的基本思想也是在LLC的基础上做改进， 来自论文 <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm</a></p>
<p>改进:用调和平均数替代几何平均数</p>
<p>调和平均数<br><img src="http://opui0kl1z.bkt.clouddn.com/harmonic_mean.jpg" alt=""></p>
<p>LLC是对各个桶取算数平均数，最终被应用到2的指数上，所以LLC取得是几何平均数。由于几何平均数对于离群值（例如这里的0）特别敏感，因此当存在离群值时，LLC的偏差就会很大.</p>
<p>当n较小,可能存在较多空桶，而这些特殊的离群值强烈干扰了几何平均数的稳定性。</p>
<p>估值公式以及误差:</p>
<p><img src="http://opui0kl1z.bkt.clouddn.com/hyperloglog_result.png" alt=""></p>
<p>根据论文中的分析结论，与LLC一样HLLC是渐近无偏估计，且其渐近标准差为：</p>
<pre><code>SE=1.04/sqrt(m)
</code></pre><p>分段偏差修正:</p>
<p>在HLLC的论文中，作者在实现建议部分还给出了在n相对于m较小或较大时的偏差修正方案<br><img src="http://opui0kl1z.bkt.clouddn.com/hllc_corretion.png" alt=""></p>
<h2 id="HyperLogLog-Plus"><a href="#HyperLogLog-Plus" class="headerlink" title="HyperLogLog Plus"></a>HyperLogLog Plus</h2><p>HyperLogLog plus 是Google的改进版。来自论文 <a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/40671.pdf" target="_blank" rel="noopener">HyperLogLog in Practice: Algorithmic Engineering of a<br>State of The Art Cardinality Estimation Algorithm</a></p>
<p>是一个工程改进版，包括使用FNV64代替原始的32位Hash函数，分段偏差修正等工程上的改进，无法严格证明</p>
<h2 id="Java中的相关实现"><a href="#Java中的相关实现" class="headerlink" title="Java中的相关实现"></a>Java中的相关实现</h2><ul>
<li><a href="https://github.com/twitter/algebird" target="_blank" rel="noopener">twitter/algebird</a>  a scala library from twitter which contains lots of different algorithms including HLL</li>
<li><a href="https://github.com/prasanthj/hyperloglog" target="_blank" rel="noopener">prasanthj/hyperloglog</a>  a detached java library for HLL </li>
<li><a href="https://github.com/addthis/stream-lib" target="_blank" rel="noopener">addthis/stream-lib</a> - another java lib(本人之前在项目中使用的这个库，还不错)</li>
<li><p><a href="https://github.com/aggregateknowledge/java-hll" target="_blank" rel="noopener">aggregateknowledge/java-hll</a>  a low-level java implementation of HLL </p>
</li>
<li><p><a href="http://koff.io/posts/comparison-of-hll/" target="_blank" rel="noopener">Comparison of HLL implementations</a> 各种实现的相关比较</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.longyubo.com/2018/10/04/Zgc_Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LongYuBo">
      <meta itemprop="description" content="Backend Developer">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LongYuBo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/04/Zgc_Introduction/" itemprop="url">
                  JDK 11 ZGC简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-04 10:51:00 / 修改时间：15:58:45" itemprop="dateCreated datePublished" datetime="2018-10-04T10:51:00+08:00">2018-10-04</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/04/Zgc_Introduction/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/10/04/Zgc_Introduction/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JDK-11-ZGC简介"><a href="#JDK-11-ZGC简介" class="headerlink" title="JDK 11 ZGC简介"></a>JDK 11 ZGC简介</h2><p>注：本文翻译自这篇<a href="https://dinfuehr.github.io/blog/a-first-look-into-zgc/" target="_blank" rel="noopener">文章</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ZGC是最近由Oracle为OpenJDK开源的新垃圾收集器。它主要由Per Liden编写。ZGC类似于<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah</a>或Azul的C4，专注于减少暂停时间的同时仍然<a href="https://en.wikipedia.org/wiki/Mark-compact_algorithm" target="_blank" rel="noopener">压缩堆</a> 。</p>
<p>虽然我不会在这里给出完整的介绍，但“压缩堆”只是意味着将仍然存活的对象移动到堆的其他区域.这样做有助于减少碎片，但通常这也意味着整个应用程序（包括其所有线程）需要暂停,这通常被称为Stop the world 。只有GC完成后，才能恢复应用程序。</p>
<p>在GC相关的文献中，应用程序通常称为mutator ，因为从GC的角度来看，应用程序会改变堆(mutates the heap)。根据堆的大小，这样的暂停可能需要几秒钟，这对于交互式应用程序来说可能是难以接受的。</p>
<p>有几种方法可以减少暂停时间：</p>
<ul>
<li>GC可以在压缩时使用多个线程（并行压缩 parallel compaction）</li>
<li>压缩工作也可以分为多个暂停（增量压缩 incremental compaction）</li>
<li>压缩堆的同时不暂停应用程序，或者只是很短时间暂停（并发压缩 concurrent compaction）</li>
<li>Go的GC就是完全不压缩堆</li>
</ul>
<p>如前所述，ZGC会进行并发压缩，这当然不是一个简单的实现功能，因此我想描述一下这是如何工作的。为什么这很复杂？</p>
<p>你需要将对象复制到另一个内存地址，同时另一个线程仍然可以读写旧对象。</p>
<p>如果对象已经复制成功，那么堆中仍有许多指向旧地址的引用需要更新到新地址。</p>
<p>虽然并发压缩（concurrent compaction）似乎是上述方案中降低暂停时间的最佳解决方案，但肯定会涉及一些权衡。因此，如果您不关心暂停时间，那么最好使用专注于吞吐量的GC。</p>
<h2 id="GC屏障-GC-Barriers"><a href="#GC屏障-GC-Barriers" class="headerlink" title="GC屏障 (GC Barriers)"></a>GC屏障 (GC Barriers)</h2><p>理解ZGC如何进行并发压缩的关键是Load barrier  (通常在GC文献中称为Read barrier).这里简单介绍一下，详细的描述请看下面的Load Barrier一节。</p>
<p>如果GC有读取屏障（Load barrier），则在从堆读取引用时，GC需要执行一些额外操作。在Java中,也就是像执行这样的代码Object xxx=obj.field时需要额外操作。</p>
<p>对于像obj.field = value这样的操作，GC也可能需要写入屏障(叫做Write Barrier或者Store Barrier)[译注：在分代GC还有引用计数中会用到写入屏障].</p>
<p>这两个操作都比较特殊因为它们在每次读取或写入堆时发生的。Load Barrier和Store Barrier的名称有点令人困惑，但注意这个屏障与CPU的<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存障碍</a>是完全不同的两个概念</p>
<p>堆中的读取和写入都非常常见，因此两种GC屏障都需要非常高效，在常见情况下就是一些汇编代码。Read barrier通常比Write Barrier大一个数量级（可能会因应用程序而异），因此Read Barrier对性能要求更高。</p>
<p>例如，分代GC通常只需要一个写屏障，不需要读屏障。ZGC则需要一个读屏障但没有写屏障。对于并发压缩，我没有看到没有读取障碍的解决方案。</p>
<p>这里需要注意：即使GC需要某种类型的屏障，只有在读取或写入堆中的引用时需要它们。读取或写入像int或double这样的基本类型是不需要屏障的.</p>
<h2 id="指针标记（Pointer-tagging-Or-Colored-Pointers-）"><a href="#指针标记（Pointer-tagging-Or-Colored-Pointers-）" class="headerlink" title="指针标记（Pointer tagging Or Colored Pointers ）"></a>指针标记（Pointer tagging Or Colored Pointers ）</h2><p>ZGC在堆引用中存储额外的<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/os_cpu/linux_x86/zGlobals_linux_x86.hpp#l59" target="_blank" rel="noopener">元数据</a> ，在x64上是64 bit（ZGC目前不支持compressed oops和 class pointers）。64位中的48位用做x64上的<a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details" target="_blank" rel="noopener">虚拟内存地址</a> 。虽然确切地说只有47位，因为第47位确定了位48-63的值（目前这些位都是0）。ZGC保留对象实际地址的前42位（在源代码中称为偏移量 ）。42位地址理论上就会有4TB的堆大小限制。其余的位用于这些标志： finalizable ， remapped ， marked1和marked0 （保留一位用于将来使用）。如下图所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 6                 4 4 4  4 4                                             0</span><br><span class="line"> 3                 7 6 5  2 1                                             0</span><br><span class="line">+-------------------+-+----+-----------------------------------------------+</span><br><span class="line">|00000000 00000000 0|0|1111|11 11111111 11111111 11111111 11111111 11111111|</span><br><span class="line">+-------------------+-+----+-----------------------------------------------+</span><br><span class="line">|                   | |    |</span><br><span class="line">|                   | |    * 41-0 Object Offset (42-bits, 4TB address space)</span><br><span class="line">|                   | |</span><br><span class="line">|                   | * 45-42 Metadata Bits (4-bits)  0001 = Marked0</span><br><span class="line">|                   |                                 0010 = Marked1</span><br><span class="line">|                   |                                 0100 = Remapped</span><br><span class="line">|                   |                                 1000 = Finalizable</span><br><span class="line">|                   |</span><br><span class="line">|                   * 46-46 Unused (1-bit, always zero)</span><br><span class="line">|</span><br><span class="line">* 63-47 Fixed (17-bits, always zero)</span><br></pre></td></tr></table></figure>
<p>在堆引用中具有元数据信息使得解引用更加昂贵，因为需要mask地址以获得没有元信息的真实地址。ZGC采用了一个很好的技巧来避免这种情况：</p>
<p>当从内存中读取时，会设置marked0 , marked1或remapped中的一个。</p>
<p>在偏移x处分配页面（allocating a page）时，ZGC将同一页面<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/os_cpu/linux_x86/zPhysicalMemoryBacking_linux_x86.cpp#l212" target="_blank" rel="noopener">映射</a>到3个不同的地址 ：</p>
<ul>
<li>for marked0  ：(0b0001 &lt;&lt; 42)  | x</li>
<li>for marked1  ： (0b0010 &lt;&lt; 42) | x</li>
<li>for remapped ： (0b0100 &lt;&lt; 42) | x</li>
</ul>
<p>因此，ZGC从地址4TB开始保留16TB的地址空间（但实际上并未使用所有这些内存）。如<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/os_cpu/linux_x86/zGlobals_linux_x86.hpp#l39" target="_blank" rel="noopener">下图</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------+ 0x0000140000000000 (20TB)</span><br><span class="line">|         Remapped View          |</span><br><span class="line">+--------------------------------+ 0x0000100000000000 (16TB)</span><br><span class="line">|     (Reserved, but unused)     |</span><br><span class="line">+--------------------------------+ 0x00000c0000000000 (12TB)</span><br><span class="line">|         Marked1 View           |</span><br><span class="line">+--------------------------------+ 0x0000080000000000 (8TB)</span><br><span class="line">|         Marked0 View           |</span><br><span class="line">+--------------------------------+ 0x0000040000000000 (4TB)</span><br></pre></td></tr></table></figure>
<p>在任何时间点，只使用这三个视图中的一个。调试时可以<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/os_cpu/linux_x86/zPhysicalMemoryBacking_linux_x86.cpp#l230" target="_blank" rel="noopener">取消映射（unmapped）</a>未使用的视图来验证正确性。</p>
<h2 id="Pages-amp-Physical-amp-Virtual-Memory"><a href="#Pages-amp-Physical-amp-Virtual-Memory" class="headerlink" title="Pages &amp; Physical &amp; Virtual Memory"></a>Pages &amp; Physical &amp; Virtual Memory</h2><p>Shenandoah将堆分成大量同样大小的区域 。除了不适合单个区域的大对象外，对象通常不会跨越多个区域。大对象被分配在多个连续区域中。我非常喜欢这种方法，因为它非常简单。</p>
<p>在这方面，ZGC与Shenandoah非常相似。在ZGC的说法中，区域称为<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zPage.hpp#l34" target="_blank" rel="noopener">页面Pages</a> 。</p>
<p>与Shenandoah的主要区别：ZGC中的页面可以有不同的大小（但在x64上总是2MB的倍数）。</p>
<p>ZGC有3种不同的页面类型： 小型 （2MB大小）， 中型 （32MB大小）和大型 （2MB的倍数）。</p>
<p>在小页面中分配小对象（最大256KB大小），在中型页面中分配中型对象（最多4MB）。大页面中分配大于4MB的对象。大页面只能存储一个对象.小页面或中间页面可以分配多个。</p>
<p>有些令人困惑的是大页面实际上可能小于中等页面（例如，对于大小为6MB的大对象）。</p>
<p>ZGC的另一个不错的特性是，它还可以区分物理内存和虚拟内存。这背后的想法是通常有足够的虚拟内存（ZGC总是4TB），而物理内存更稀缺。物理内存可以扩展到最大堆大小（使用-Xmx设置），因此这比4 TB的虚拟内存要小得多。在ZGC中分配特定大小的页面意味着分配物理和虚拟内存。在ZGC中，物理内存不需要是连续的，虚拟内存空间是连续的。</p>
<p>为什么说这是一个不错的属性？</p>
<p>分配连续范围的虚拟内存是很容易的，因为我们通常有足够的虚拟内存。但在物理内存中有3个大小为2MB的空闲页面的情况很普通，但是对于大型对象分配我们需要6MB的连续内存。有足够的空闲物理内存，但不幸的是这个内存是不连续的。ZGC能够将这些非连续的物理页面映射到单个连续的虚拟内存空间。如果无法映射，我们就会耗尽内存（发生OOM）</p>
<h2 id="标记和重新安置对象（Marking-amp-Relocating-objects）"><a href="#标记和重新安置对象（Marking-amp-Relocating-objects）" class="headerlink" title="标记和重新安置对象（Marking &amp; Relocating objects）"></a>标记和重新安置对象（Marking &amp; Relocating objects）</h2><p>垃圾回收主要分为两个阶段：标记和重新安置（实际上不止这两个阶段，你可以查阅<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zDriver.cpp#l301" target="_blank" rel="noopener">源码</a>）。</p>
<p>[译注：重新安置（Relocating）指的是把对象从一个内存区域移到另外一个区域，重映射(Remapping)只的是把指向老的地址的引用更新到新的地址]</p>
<p>一次GC从标记阶段开始，标记所有可到达的对象。在这个阶段结束时，我们知道哪些对象仍然存活，哪些对象是垃圾。ZGC将此信息存储在每个页面的Live Map中。Live Map是一个<a href="https://en.wikipedia.org/wiki/Bit_array" target="_blank" rel="noopener">位图(bitmap)</a> ，用于存储给定索引处的对象是否可达和/或最终可达（对于具有finalize method的对象而言）。</p>
<p>在标记阶段，应用程序线程中的load-barrier将未标记的引用推送到线程局部标记缓冲区。只要此缓冲区已满，GC线程就可以获得此缓冲区的所有权，并以递归方式遍历此缓冲区中的所有可到达对象。在应用程序线程中标记只是将引用推送到缓冲区，GC线程负责遍历对象图并更新Live map.</p>
<p>标记阶段结束后，ZGC要重新安置 Relocation set中的所有活动对象。</p>
<p>Relocation Set表示一组需要被回收的页面（Pages)，例如那些垃圾最多的页面。存活的对象由GC线程或应用程序线程通过读取屏障（Load Barrier）重新安置（relocated）（也就是放到新的地址去）.ZGC为Relocation set中的每个页面分配Forwarding table.</p>
<p>Forwarding table基本上是一个hash map，它存储一个对象已被重新安置到的地址（如果该对象已经被重新安置）。</p>
<p>ZGC方法的优点是我们只需要为relocation set中的页面分配forwarding table的空间.<br>相比之下，Shenandoah将转发指针存储在每个对象本身，这样就谁有一些额外的内存开销。</p>
<p>GC线程遍历 Relocation set中的存活对象，并重新安置（relocate）尚未重新安置的对象。这时可能发生应用程序线程和GC线程同时重新安置（relocate）同一个对象，在这种情况下，谁先relocate谁获胜，ZGC使用原子CAS操作来确定胜者。</p>
<p>当不处于marking阶段时，load-barrier会重新安置(relocates )/重新映射(remaps )从堆加载的所有引用。这确保了mutator看到的每个新引用都已指向对象的最新副本。重新映射（remaps）对象就是在forwarding table中查找新的对象地址。</p>
<p>一旦GC线程完成了relocation set的处理，重新安置阶段就完成了。虽然这意味着所有对象都已重新安置，但通常仍会有引用指向relocation set，需要将其重新映射（remapped ）到新地址。这些引用会被Load-Barrier自我修复。如果对于这些引用的读取发生的不够快，（也就是这段时间内，应用程序没有读到这些指向relocation set的引用），这些引用会在下一次mark阶段给修复。这意味着标记阶段还需要检查 forward table以重新映射(remap) （但不重新安置 ，所有对象之前阶段都保证被重新安置）对象到它们的新地址。</p>
<p>这也解释了为什么对象引用中有两个标记位（marked0 和marked1 ）。标记阶段在标记的marked0和marked1位之间交替。在重新安置阶段之后，仍可能存在未重定向（remapped）的引用，所以我们需要知道上一个gc周期的情况。如果新的标记阶段使用相同的标记位，则Load-Barrier就知道该引用为已标记。</p>
<p>(译注：这里看起来像是GC周期remap和mark可以重叠，实际上确实是重叠的。如图所示：<br><img src="http://opui0kl1z.bkt.clouddn.com/zgc-overlap.png" alt="gc phase"><br>更详细的信息可以看这个<a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf" target="_blank" rel="noopener">Slide</a>)</p>
<h2 id="Load-Barrier"><a href="#Load-Barrier" class="headerlink" title="Load-Barrier"></a>Load-Barrier</h2><p>从堆中读取引用时，ZGC需要一个所谓的load-barrier（也称为read-barrier）。每次Java程序访问对象类型的字段时，我们都需要插入此load-barrier，例如obj.field 。访问某些其他原始类型的字段不需要屏障，例如obj.anInt或obj.anDouble 。ZGC不需要obj.field = someValue存储/写入障碍。</p>
<p>根据GC当前所处的阶段（存储在全局变量<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zGlobals.cpp#l27" target="_blank" rel="noopener">ZGlobalPhase</a>中 ），如果尚未标记或重新安置对象，则屏障会标记对象或重新安置它</p>
<p>全局变量<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zGlobals.cpp#l33" target="_blank" rel="noopener">ZAddressGoodMask</a>和<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zGlobals.cpp#l34" target="_blank" rel="noopener">ZAddressBadMask</a><br>存储对应的掩码，该掩码确定引用是否已被认为是好的（这意味着已经标记或重新映射/重新安置remapped/relocated）或者是否仍然需要一些操作。这些变量仅在标记开始阶段和重新安置阶段<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zAddress.cpp#l31" target="_blank" rel="noopener">同时</a>改变.ZGC源代码中的这个<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zGlobals.hpp#l99" target="_blank" rel="noopener">表格</a>可以很好地概述这些掩码的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">               GoodMask         BadMask          WeakGoodMask     WeakBadMask</span><br><span class="line">               --------------------------------------------------------------</span><br><span class="line">Marked0        001              110              101              010</span><br><span class="line">Marked1        010              101              110              001</span><br><span class="line">Remapped       100              011              100              011</span><br></pre></td></tr></table></figure>
<p>屏障的汇编代码可以在<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/cpu/x86/macroAssembler_x86.cpp#l6706" target="_blank" rel="noopener">MacroAssembler</a> for x64中看到，我只会为这个屏障显示一些伪汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [r10 + some_field_offset]</span><br><span class="line">test rax, [address of ZAddressBadMask]</span><br><span class="line">jnz load_barrier_mark_or_relocate</span><br><span class="line"></span><br><span class="line"># otherwise reference in rax is considered good</span><br></pre></td></tr></table></figure>
<p>第一个汇编指令从堆读取引用： r10存储对象引用， some_field_offset是一些字段偏移常量。加载的引用存储在rax寄存器中。</p>
<p>然后针对当前的坏掩码测试该引用（这只是一个位与）。此处不需要同步，因为ZAddressBadMask仅在STW时才更新。如果结果不为零，我们需要执行屏障。</p>
<p>屏障需要根据我们当前所处的GC阶段标记或重新安置对象。在此操作之后， 他需要更新存储在r10 + some_field_offset中的引用来指向新引用。这步操作是必要的，以便来该字段的后续加载返回正确的引用。</p>
<p>由于我们可能需要更新引用地址，因此我们需要使用两个寄存器r10和rax作为加载的引用和对象地址。正确的引用也需要存储到寄存器rax中 ，这样在后面的执行过程中我们就已经加载了正确的引用。</p>
<p>由于每个引用都需要标记或重新安置，因此在开始标记或重新安置阶段后，吞吐量可能会立即降低。当大多数引用被修复时，这应该会变得更快。</p>
<h2 id="Stop-the-World-停顿"><a href="#Stop-the-World-停顿" class="headerlink" title="Stop-the-World 停顿"></a>Stop-the-World 停顿</h2><p>ZGC并没有彻底摆脱STW。收集器在<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zDriver.cpp#l304" target="_blank" rel="noopener">开始标记</a>,<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zDriver.cpp#l316" target="_blank" rel="noopener">结束标记</a>和<a href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/share/gc/z/zDriver.cpp#l356" target="_blank" rel="noopener">开始重新安置</a>时需要暂停。但这种暂停通常很短,只有几毫秒。</p>
<p>当开始标记时，ZGC遍历所有线程堆栈以标记root set。root set是遍历对象图的开始的地方。root set通常由本地和全局变量组成，但也包括其他内部VM结构（例如JNI句柄）。</p>
<p>结束标记阶段时需要再次暂停。在此暂停中，GC需要清空并遍历所有线程局部标记缓冲区。由于GC可能会发现一个未标记的大型子图，因此可能需要更长时间。ZGC试图通过在1毫秒后停止标记阶段的结束来避免这种情况。它返回到并发标记阶段，直到遍历整个对象图，然后可以再次开始结束标记阶段</p>
<p>启动重新安置阶段会再次暂停应用程序。此阶段与开始标记非常相似，不同之处在于此阶段重新安置Root Set中的对象。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望我能简单介绍一下ZGC。我当然无法在一篇博客文章中描述有关此GC的所有细节。如果您需要更多信息，ZGC是<a href="http://cr.openjdk.java.net/~pliden/zgc/" target="_blank" rel="noopener">开源</a>的因此可以研究整个实现。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.longyubo.com/2018/08/12/Kafka_network_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LongYuBo">
      <meta itemprop="description" content="Backend Developer">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LongYuBo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Kafka_network_2/" itemprop="url">
                  Kafka源码学习:网络通信层(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-12 15:07:35" itemprop="dateCreated datePublished" datetime="2018-08-12T15:07:35+08:00">2018-08-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-02 14:15:29" itemprop="dateModified" datetime="2018-10-02T14:15:29+08:00">2018-10-02</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/12/Kafka_network_2/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/12/Kafka_network_2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kafka源码学习-网络通信层-2"><a href="#Kafka源码学习-网络通信层-2" class="headerlink" title="Kafka源码学习:网络通信层(2)"></a>Kafka源码学习:网络通信层(2)</h2><p>上一篇里面讲了Kafka的服务端是如何收发请求的，这一篇主要学习一下网络层收到的数据是如何跟业务逻辑层打交道的</p>
<p>上篇文章讲到了processCompletedReceives方法里面把completedReceives队列里面的NetworkReceive拿出来组成了RequestChannel.Session对象，然后把这个Session对象放到了RequestChannel.Request对象里面。<br>其中Session由一个principal和一个远端地址构成</p>
<p>Request则是由之前读到的请求的payload（NetworkReceive.payload）和当前的processorID，connectionId等信息组成，还有header:RequestHeader跟body:AbstractRequest两个成员。使用payload构造header和body。<br>请求头里面包含了api_key,api_version等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHeader</span> <span class="keyword">extends</span> <span class="title">AbstractRequestResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Field API_KEY_FIELD = REQUEST_HEADER.get(<span class="string">"api_key"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Field API_VERSION_FIELD = REQUEST_HEADER.get(<span class="string">"api_version"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Field CLIENT_ID_FIELD = REQUEST_HEADER.get(<span class="string">"client_id"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Field CORRELATION_ID_FIELD = REQUEST_HEADER.get(<span class="string">"correlation_id"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> apiKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> apiVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> correlationId;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求体根据请求头中不同的apiKey来构造不同的请求体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRequest.getRequest(header.apiKey, header.apiVersion, buffer)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractRequest <span class="title">getRequest</span><span class="params">(<span class="keyword">int</span> requestId, <span class="keyword">short</span> versionId, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        ApiKeys apiKey = ApiKeys.forId(requestId);</span><br><span class="line">        <span class="keyword">switch</span> (apiKey) &#123;</span><br><span class="line">            <span class="keyword">case</span> PRODUCE:</span><br><span class="line">                <span class="keyword">return</span> ProduceRequest.parse(buffer, versionId);</span><br><span class="line">            <span class="keyword">case</span> FETCH:</span><br><span class="line">                <span class="keyword">return</span> FetchRequest.parse(buffer, versionId);</span><br><span class="line">            <span class="keyword">case</span> LIST_OFFSETS:</span><br><span class="line">            <span class="comment">//以下省略</span></span><br></pre></td></tr></table></figure>
<p>这样一个完整的request就构造出来了，构造出来之后，放入了这个processor所有的请求队列里面（RequestChannel.requestQueue.put(request)）,processCompletedReceives方法结束。</p>
<p>放入队列之后谁又来拿出来呢？</p>
<p>放入队列的请求被一个叫KafkaRequestHandler的类拿出来并且处理，代码如下：（我通过IDE的OPEN CALL hierarchy找到的）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A thread that answers kafka requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaRequestHandler</span>(<span class="params">id: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          brokerId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          val aggregateIdleMeter: <span class="type">Meter</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          val totalHandlerThreads: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          val requestChannel: <span class="type">RequestChannel</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          apis: <span class="type">KafkaApis</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Runnable</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Request Handler "</span> + id + <span class="string">" on Broker "</span> + brokerId + <span class="string">"], "</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> req : <span class="type">RequestChannel</span>.<span class="type">Request</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (req == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We use a single meter for aggregate idle percentage for the thread pool.</span></span><br><span class="line">          <span class="comment">// Since meter is calculated as total_recorded_value / time_window and</span></span><br><span class="line">          <span class="comment">// time_window is independent of the number of threads, each recorded idle</span></span><br><span class="line">          <span class="comment">// time should be discounted by # threads.</span></span><br><span class="line">          <span class="keyword">val</span> startSelectTime = time.nanoseconds</span><br><span class="line">          req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line">          <span class="keyword">val</span> idleTime = time.nanoseconds - startSelectTime</span><br><span class="line">          aggregateIdleMeter.mark(idleTime / totalHandlerThreads)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(req eq <span class="type">RequestChannel</span>.<span class="type">AllDone</span>) &#123;</span><br><span class="line">          debug(<span class="string">"Kafka request handler %d on broker %d received shut down command"</span>.format(</span><br><span class="line">            id, brokerId))</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        req.requestDequeueTimeMs = time.milliseconds</span><br><span class="line">        trace(<span class="string">"Kafka request handler %d on broker %d handling request %s"</span>.format(id, brokerId, req))</span><br><span class="line">        apis.handle(req)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Exception when handling request"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>(): <span class="type">Unit</span> = requestChannel.sendRequest(<span class="type">RequestChannel</span>.<span class="type">AllDone</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaRequestHandlerPool</span>(<span class="params">val brokerId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              val requestChannel: <span class="type">RequestChannel</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              val apis: <span class="type">KafkaApis</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              time: <span class="type">Time</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              numThreads: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a meter to track the average free capacity of the request handlers */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> aggregateIdleMeter = newMeter(<span class="string">"RequestHandlerAvgIdlePercent"</span>, <span class="string">"percent"</span>, <span class="type">TimeUnit</span>.<span class="type">NANOSECONDS</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Request Handler on Broker "</span> + brokerId + <span class="string">"], "</span></span><br><span class="line">  <span class="keyword">val</span> threads = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Thread</span>](numThreads)</span><br><span class="line">  <span class="keyword">val</span> runnables = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">KafkaRequestHandler</span>](numThreads)</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">    runnables(i) = <span class="keyword">new</span> <span class="type">KafkaRequestHandler</span>(i, brokerId, aggregateIdleMeter, numThreads, requestChannel, apis, time)</span><br><span class="line">    threads(i) = <span class="type">Utils</span>.daemonThread(<span class="string">"kafka-request-handler-"</span> + i, runnables(i))</span><br><span class="line">    threads(i).start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>() &#123;</span><br><span class="line">    info(<span class="string">"shutting down"</span>)</span><br><span class="line">    <span class="keyword">for</span>(handler &lt;- runnables)</span><br><span class="line">      handler.shutdown</span><br><span class="line">    <span class="keyword">for</span>(thread &lt;- threads)</span><br><span class="line">      thread.join</span><br><span class="line">    info(<span class="string">"shut down completely"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个runnable，并且通过while(true)不停的拿请求出来，最后交给 apis.handle(req)方法来处理这个请求。</p>
<p>这个KafkaRequestHandler被下面的KafkaRequestHandlerPool给拉起来的。可以从代码看到是直接拉起了numThreads个线程，共用一个apis和requestChannel实例。</p>
<p>这个api跟kafkaRequestHandlerPool都是在kafkaServer.startup里面拉起来的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kafkaServer.startup方法</span></span><br><span class="line"><span class="comment">/* start processing requests */</span></span><br><span class="line">apis = <span class="keyword">new</span> <span class="type">KafkaApis</span>(socketServer.requestChannel, replicaManager, adminManager, groupCoordinator,</span><br><span class="line">  kafkaController, zkUtils, config.brokerId, config, metadataCache, metrics, authorizer, quotaManagers,</span><br><span class="line">  clusterId, time)</span><br><span class="line"></span><br><span class="line">requestHandlerPool = <span class="keyword">new</span> <span class="type">KafkaRequestHandlerPool</span>(config.brokerId, socketServer.requestChannel, apis, time,</span><br><span class="line">  config.numIoThreads)</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到KafkaRequestHandlerPool这个处理请求的线程池的requestChannel是从socketServer里面直接拿到的，这个池的大小就是config.numIoThreads，与processor数量一致。</p>
<p>现在回到KafkaRequestHandler里面，看他的run方法最后是apis.handle(req)，这里简单看一下是如何处理请求的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     trace(<span class="string">"Handling request:%s from connection %s;securityProtocol:%s,principal:%s"</span>.</span><br><span class="line">       format(request.requestDesc(<span class="literal">true</span>), request.connectionId, request.securityProtocol, request.session.principal))</span><br><span class="line">     <span class="type">ApiKeys</span>.forId(request.requestId) <span class="keyword">match</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">PRODUCE</span> =&gt; handleProducerRequest(request)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">FETCH</span> =&gt; handleFetchRequest(request)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_OFFSETS</span> =&gt; handleOffsetRequest(request)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">METADATA</span> =&gt; handleTopicMetadataRequest(request)</span><br><span class="line">       <span class="comment">//后面省略</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这里是根据requestId来的一个模式匹配（可以理解成java里面的switch，scala没有switch）。然后进入对应的handleXXX函数，在具体的业务逻辑完成之后，调用 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, respBody))</span><br></pre></td></tr></table></figure>
<p>把响应发送到对应processor的响应队列中。然后响应被上一篇文章说的流程给发送出去.<br>handleXXX里面由于是多线程共同调用的，不少代码都是有锁来保护的。</p>
<p>总结一下：<br>Processor线程负责解析请求，并把请求放入到请求队列中，另一个HandlerPool不停的从请求队列里面拿出已经解析好的请求，并执行对应的业务逻辑，完成业务逻辑之后把响应组成response放到对应processorID的响应队列中，由对应的processor发出去。<br>这个handlerPool的大小与IO线程数目一致。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.longyubo.com/2018/07/01/Kafka_network_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LongYuBo">
      <meta itemprop="description" content="Backend Developer">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LongYuBo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/Kafka_network_1/" itemprop="url">
                  Kafka源码学习:网络通信层(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-01 16:23:06" itemprop="dateCreated datePublished" datetime="2018-07-01T16:23:06+08:00">2018-07-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-02 14:15:05" itemprop="dateModified" datetime="2018-10-02T14:15:05+08:00">2018-10-02</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/01/Kafka_network_1/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/01/Kafka_network_1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kafka源码学习-网络通信层-1"><a href="#Kafka源码学习-网络通信层-1" class="headerlink" title="Kafka源码学习:网络通信层(1)"></a>Kafka源码学习:网络通信层(1)</h2><p>因为工作过程中基本没有涉及到直接使用网络API编程的，所以借这次学习Kafka源码的机会，一起把Java NIO Api以及网络的编程模型套路一起学习一下。</p>
<p>本文主要目的是学习Kafka如何使用NIO与客户端通信的:包括连接的建立，数据的读取，给客户端的应答。</p>
<p>本文涉及的Kafka的源码版本为0.10.2。</p>
<p>文章比较长，不想看细节可以直接看<a href="#kafka_network_1_conclution">总结</a> </p>
<h3 id="服务器的整体启动流程"><a href="#服务器的整体启动流程" class="headerlink" title="服务器的整体启动流程"></a>服务器的整体启动流程</h3><p>服务器是在KafkaServer类的startUp方法中的ServerSocket.startUp方法拉起来。下面看下这个ServerSocket.startUp具体是怎么做的。</p>
<p>startUp根据配置信息中的每个Endpoint（Ip+Port）拉起一个Acceptor，然后这个Acceptor再拉起对应num.network.threads数目的Processor（这里的Acceptor和Processor都是runnable，都是拉起单独的线程跑的）</p>
<p>Acceptor的作用是接受请求，它在ServerChannel上注册了一个Selector，这个Selector注册了SelectionKey.OP_ACCEPT事件用来接受请求。如果有Accept进来，就使用RoundRobin的方式决定一个Processor，然后拿到客户端的Channel，配置好非阻塞模式，放入选出的Processor的newConnections队列里面。</p>
<p>Acceptor启动的时候会拉起num.network.threads数目的Processor。</p>
<p> 这一块的代码如下</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">//初始化Acceptor与Processor</span></span><br><span class="line">     <span class="keyword">var</span> processorBeginIndex = <span class="number">0</span></span><br><span class="line">     config.listeners.foreach &#123; endpoint =&gt;</span><br><span class="line">     <span class="keyword">val</span> listenerName = endpoint.listenerName</span><br><span class="line">     <span class="keyword">val</span> securityProtocol = endpoint.securityProtocol</span><br><span class="line">     <span class="keyword">val</span> processorEndIndex = processorBeginIndex + numProcessorThreads</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i &lt;- processorBeginIndex until processorEndIndex)</span><br><span class="line">       processors(i) = newProcessor(i, connectionQuotas, listenerName, securityProtocol)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">val</span> acceptor = <span class="keyword">new</span> <span class="type">Acceptor</span>(endpoint, sendBufferSize, recvBufferSize, brokerId,</span><br><span class="line">       processors.slice(processorBeginIndex, processorEndIndex), connectionQuotas)</span><br><span class="line">     acceptors.put(endpoint, acceptor)</span><br><span class="line">     <span class="type">Utils</span>.newThread(<span class="string">s"kafka-socket-acceptor-<span class="subst">$listenerName</span>-<span class="subst">$securityProtocol</span>-<span class="subst">$&#123;endpoint.port&#125;</span>"</span>, acceptor, <span class="literal">false</span>).start()</span><br><span class="line">     acceptor.awaitStartup()</span><br><span class="line"></span><br><span class="line">     processorBeginIndex = processorEndIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//Acceptor拉起Processor</span></span><br><span class="line">     <span class="keyword">private</span>[kafka] <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span>(<span class="params">val endPoint: <span class="type">EndPoint</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           val sendBufferSize: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           val recvBufferSize: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           brokerId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           processors: <span class="type">Array</span>[<span class="type">Processor</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">                           connectionQuotas: <span class="type">ConnectionQuotas</span></span>) <span class="keyword">extends</span> <span class="title">AbstractServerThread</span>(<span class="params">connectionQuotas</span>) <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> nioSelector = <span class="type">NSelector</span>.open()</span><br><span class="line"> <span class="keyword">val</span> serverChannel = openServerSocket(endPoint.host, endPoint.port)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.synchronized &#123;</span><br><span class="line"> <span class="comment">//拉起Processor</span></span><br><span class="line"> processors.foreach &#123; processor =&gt;</span><br><span class="line">   <span class="type">Utils</span>.newThread(<span class="string">s"kafka-network-thread-<span class="subst">$brokerId</span>-<span class="subst">$&#123;endPoint.listenerName&#125;</span>-<span class="subst">$&#123;endPoint.securityProtocol&#125;</span>-<span class="subst">$&#123;processor.id&#125;</span>"</span>,</span><br><span class="line">     processor, <span class="literal">false</span>).start()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Acceptor 的主逻辑</span></span><br><span class="line">   <span class="keyword">var</span> currentProcessor = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">val</span> ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line">       <span class="keyword">if</span> (ready &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">val</span> keys = nioSelector.selectedKeys()</span><br><span class="line">         <span class="keyword">val</span> iter = keys.iterator()</span><br><span class="line">         <span class="keyword">while</span> (iter.hasNext &amp;&amp; isRunning) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">val</span> key = iter.next</span><br><span class="line">             iter.remove()</span><br><span class="line">             <span class="keyword">if</span> (key.isAcceptable)</span><br><span class="line">               accept(key, processors(currentProcessor))</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Unrecognized key state for acceptor thread."</span>)</span><br><span class="line"></span><br><span class="line">             <span class="comment">// round robin to the next processor thread</span></span><br><span class="line">             currentProcessor = (currentProcessor + <span class="number">1</span>) % processors.length</span><br><span class="line">           &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">             <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while accepting connection"</span>, e)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> &#123;</span><br><span class="line">       <span class="comment">// We catch all the throwables to prevent the acceptor thread from exiting on exceptions due</span></span><br><span class="line">       <span class="comment">// to a select operation on a specific channel or a bad request. We don't want</span></span><br><span class="line">       <span class="comment">// the broker to stop responding to requests from other clients in these scenarios.</span></span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error occurred"</span>, e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//Accept方法具体实现</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(key: <span class="type">SelectionKey</span>, processor: <span class="type">Processor</span>) &#123;</span><br><span class="line">     <span class="keyword">val</span> serverSocketChannel = key.channel().asInstanceOf[<span class="type">ServerSocketChannel</span>]</span><br><span class="line">     <span class="keyword">val</span> socketChannel = serverSocketChannel.accept() <span class="comment">//这个socketChannel就是客户端的channel了</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     connectionQuotas.inc(socketChannel.socket().getInetAddress)</span><br><span class="line">     socketChannel.configureBlocking(<span class="literal">false</span>)</span><br><span class="line">     socketChannel.socket().setTcpNoDelay(<span class="literal">true</span>)</span><br><span class="line">     socketChannel.socket().setKeepAlive(<span class="literal">true</span>)</span><br><span class="line">     <span class="keyword">if</span> (sendBufferSize != <span class="type">Selectable</span>.<span class="type">USE_DEFAULT_BUFFER_SIZE</span>)</span><br><span class="line">         socketChannel.socket().setSendBufferSize(sendBufferSize)</span><br><span class="line"></span><br><span class="line">     debug(<span class="string">"Accepted connection from %s on %s and assigned it to processor %d, sendBufferSize [actual|requested]: [%d|%d] recvBufferSize [actual|requested]: [%d|%d]"</span></span><br><span class="line">             .format(socketChannel.socket.getRemoteSocketAddress, socketChannel.socket.getLocalSocketAddress, processor.id,</span><br><span class="line">                 socketChannel.socket.getSendBufferSize, sendBufferSize,</span><br><span class="line">                 socketChannel.socket.getReceiveBufferSize, recvBufferSize))</span><br><span class="line"></span><br><span class="line">     processor.accept(socketChannel)</span><br><span class="line">     &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> e: <span class="type">TooManyConnectionsException</span> =&gt;</span><br><span class="line">         info(<span class="string">"Rejected connection from %s, address already has the configured maximum of %d connections."</span>.format(e.ip, e.count))</span><br><span class="line">         close(socketChannel)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//processor.accept具体实现，其实是放入了newConnections队列里面</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(socketChannel: <span class="type">SocketChannel</span>) &#123;</span><br><span class="line">     newConnections.add(socketChannel)</span><br><span class="line">     wakeup()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Processor的作用主要是处理新建的连接，读取客户端的请求，响应客户端，处理客户端关闭。<br>下面主要来说下Processor的构成还有是如何处理这些动作的。</p>
<h3 id="Processor结构"><a href="#Processor结构" class="headerlink" title="Processor结构"></a>Processor结构</h3><p>Processor里面组成部分先介绍3个：一个Selector(这个selector是kafka包装过nioSelector的,里面定义了已收到和已发出的队列等等)，一个上文提到的newConnections队列和一个RequestChannel。<br>这个RequestChannel是一个类，重要的结构有两个，一个RequestQueue ，一个ResponseQueues看名字就知道是用来存储请求和响应的。具体代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestChannel</span>(<span class="params">val numProcessors: <span class="type">Int</span>, val queueSize: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> responseListeners: <span class="type">List</span>[(<span class="type">Int</span>) =&gt; <span class="type">Unit</span>] = <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> requestQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Request</span>](queueSize)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> responseQueues = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">BlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]](numProcessors)</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until numProcessors)</span><br><span class="line">    responseQueues(i) = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]()</span><br></pre></td></tr></table></figure>
<p>上文说过Processor是个Runnable，那么直接看它的run方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  startupComplete()</span><br><span class="line">  <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// setup any new connections that have been queued up</span></span><br><span class="line">      configureNewConnections()</span><br><span class="line">      <span class="comment">// register any new responses for writing</span></span><br><span class="line">      <span class="comment">// 这个Response只是把response写到了transportLayer，并没有实际发送，实际发送是在下面的poll做的</span></span><br><span class="line">      processNewResponses()</span><br><span class="line">      poll()</span><br><span class="line">      processCompletedReceives()</span><br><span class="line">      processCompletedSends()</span><br><span class="line">      processDisconnected()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// We catch all the throwables here to prevent the processor thread from exiting. We do this because</span></span><br><span class="line">      <span class="comment">// letting a processor exit might cause a bigger impact on the broker. Usually the exceptions thrown would</span></span><br><span class="line">      <span class="comment">// be either associated with a specific socket channel or a bad request. We just ignore the bad socket channel</span></span><br><span class="line">      <span class="comment">// or request. This behavior might need to be reviewed if we see an exception that need the entire broker to stop.</span></span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">        error(<span class="string">"Processor got uncaught exception."</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">"Closing selector - processor "</span> + id)</span><br><span class="line">  swallowError(closeAll())</span><br><span class="line">  shutdownComplete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try里面的代码说明了processor做的事情，下面逐一说明</p>
<h3 id="配置新进连接-ConfigureNewConnections"><a href="#配置新进连接-ConfigureNewConnections" class="headerlink" title="配置新进连接 ConfigureNewConnections"></a>配置新进连接 ConfigureNewConnections</h3><p>配置新连接主要做了一件事情就是把Acceptor放到newConnection队列里面的客户端的channel拿出来，然后把channel注册上Selector和对应的SelectionKey.OP_READ，这样在select的时候就能拿到客户端发出的请求了，然后把channel进行包装成KafkaChannel并attach到原始channel上。根据channel的基本信息构建一个key，放入Selector维护的ChannelMap里面。具体代码如下:</p>
<p>这里说下KafkaChannel这个类，这个类里面有个TransportLayer和一个Send属性。TransportLayerk可以由一个SelectionKey构建出来，他主要负责底层对channel的read,write,close等操作（因为之前把channel attach到SelectionKey上了所以可以拿到channel）。send属性是用来维护要发送的应答的。Kafka实际是一个request-response模型，一个channel同一时间只有一个请求，不会有多个，所以send只有一个。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置新连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">configureNewConnections</span></span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!newConnections.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">val</span> channel = newConnections.poll()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        debug(<span class="string">s"Processor <span class="subst">$id</span> listening to new connection from <span class="subst">$&#123;channel.socket.getRemoteSocketAddress&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> localHost = channel.socket().getLocalAddress.getHostAddress</span><br><span class="line">        <span class="keyword">val</span> localPort = channel.socket().getLocalPort</span><br><span class="line">        <span class="keyword">val</span> remoteHost = channel.socket().getInetAddress.getHostAddress</span><br><span class="line">        <span class="keyword">val</span> remotePort = channel.socket().getPort</span><br><span class="line">        <span class="keyword">val</span> connectionId = <span class="type">ConnectionId</span>(localHost, localPort, remoteHost, remotePort).toString</span><br><span class="line">        selector.register(connectionId, channel)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// We explicitly catch all non fatal exceptions and close the socket to avoid a socket leak. The other</span></span><br><span class="line">        <span class="comment">// throwables will be caught in processor and logged as uncaught exceptions.</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">          <span class="keyword">val</span> remoteAddress = channel.getRemoteAddress</span><br><span class="line">          <span class="comment">// need to close the channel here to avoid a socket leak.</span></span><br><span class="line">          close(channel)</span><br><span class="line">          error(<span class="string">s"Processor <span class="subst">$id</span> closed connection from <span class="subst">$remoteAddress</span>"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void register(<span class="type">String</span> id, <span class="type">SocketChannel</span> socketChannel) <span class="keyword">throws</span> <span class="type">ClosedChannelException</span> &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> key = socketChannel.register(nioSelector, <span class="type">SelectionKey</span>.<span class="type">OP_READ</span>);</span><br><span class="line">        <span class="type">KafkaChannel</span> channel = channelBuilder.buildChannel(id, key, maxReceiveSize);</span><br><span class="line">        key.attach(channel);</span><br><span class="line">        <span class="keyword">this</span>.channels.put(id, channel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理响应-ProcessNewResponses"><a href="#处理响应-ProcessNewResponses" class="headerlink" title="处理响应 ProcessNewResponses"></a>处理响应 ProcessNewResponses</h3><p>根据当前到Processor的序号（上文提到了Processor是多个）从RequestChannel里面拿到属于自己的响应队列，然后拿出响应并根据responseAction做出响应。这里的responseAction有3种：</p>
<ol>
<li>NoOpAction 啥也不做，只把SelectionKey.OP_READ重新注册到selector上</li>
<li>SendAction 根据response里面的destination（就是channelId）拿到对应的KafkaChannel对象，把要发送的Send对象放到KafkaChannel对应的Send字段上，然后把写操作打开( this.transportLayer.addInterestOps(SelectionKey.OP_WRITE))，注意并没有实际发送.然后在inflightResponses记录下这个响应</li>
<li>CloseConnectionAction 把对应channel给close掉。</li>
</ol>
<p>SendAction有关代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//processor.sendResponse</span></span><br><span class="line">  <span class="keyword">protected</span>[network] <span class="function">def <span class="title">sendResponse</span><span class="params">(response: RequestChannel.Response)</span> </span>&#123;</span><br><span class="line">    trace(s<span class="string">"Socket server received response to send, registering for write and sending data: $response"</span>)</span><br><span class="line">    val channel = selector.channel(response.responseSend.destination)</span><br><span class="line">    <span class="comment">// `channel` can be null if the selector closed the connection because it was idle for too long</span></span><br><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">      warn(s<span class="string">"Attempting to send response via channel for which there is no open connection, connection id $id"</span>)</span><br><span class="line">      response.request.updateRequestMetrics()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      selector.send(response.responseSend)</span><br><span class="line">      inflightResponses += (response.request.connectionId -&gt; response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//selector.send</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Send send)</span> </span>&#123;</span><br><span class="line">        String connectionId = send.destination();</span><br><span class="line">        <span class="keyword">if</span> (closingChannels.containsKey(connectionId))</span><br><span class="line">            <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            KafkaChannel channel = channelOrFail(connectionId, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.setSend(send);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">                <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">                close(channel, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSend</span><span class="params">(Send send)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.send != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Attempt to begin a send operation with prior send operation still in progress."</span>);</span><br><span class="line">        <span class="keyword">this</span>.send = send;</span><br><span class="line">        <span class="keyword">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里明显能看出对于一个Channel上，send只能有一个</p>
<h3 id="真正的读写-poll"><a href="#真正的读写-poll" class="headerlink" title="真正的读写 poll"></a>真正的读写 poll</h3><p>poll方法通过对selector进行select来确定readyKeys的数量，如果大于0，就pollSelectionKeys，具体看下poll和pollSelectionKeys这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//processor.poll</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> selector.poll(<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e @ (_: IllegalStateException | _: IOException) =&gt;</span><br><span class="line">        error(s<span class="string">"Closing processor $id due to illegal state or IO exception"</span>)</span><br><span class="line">        swallow(closeAll())</span><br><span class="line">        shutdownComplete()</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//selector.poll</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout should be &gt;= 0"</span>);</span><br><span class="line"></span><br><span class="line">        clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check ready keys */</span></span><br><span class="line">        <span class="keyword">long</span> startSelect = time.nanoseconds();</span><br><span class="line">        <span class="keyword">int</span> readyKeys = select(timeout);</span><br><span class="line">        <span class="keyword">long</span> endSelect = time.nanoseconds();</span><br><span class="line">        <span class="keyword">this</span>.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (readyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty()) &#123;</span><br><span class="line">            pollSelectionKeys(<span class="keyword">this</span>.nioSelector.selectedKeys(), <span class="keyword">false</span>, endSelect);</span><br><span class="line">            pollSelectionKeys(immediatelyConnectedKeys, <span class="keyword">true</span>, endSelect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addToCompletedReceives();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endIo = time.nanoseconds();</span><br><span class="line">        <span class="keyword">this</span>.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we use the time at the end of select to ensure that we don't close any connections that</span></span><br><span class="line">        <span class="comment">// have just been processed in pollSelectionKeys</span></span><br><span class="line">        maybeCloseOldestConnection(endSelect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pollSelectionKeys</span><span class="params">(Iterable&lt;SelectionKey&gt; selectionKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isImmediatelyConnected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">long</span> currentTimeNanos)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            iterator.remove();</span><br><span class="line">            KafkaChannel channel = channel(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// register all per-connection metrics at once</span></span><br><span class="line">            sensors.maybeRegisterConnectionMetrics(channel.id());</span><br><span class="line">            <span class="keyword">if</span> (idleExpiryManager != <span class="keyword">null</span>)</span><br><span class="line">                idleExpiryManager.update(channel.id(), currentTimeNanos);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* complete any connections that have finished their handshake (either normally or immediately) */</span></span><br><span class="line">            	<span class="comment">//似乎是客户端连接服务器的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (isImmediatelyConnected || key.isConnectable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channel.finishConnect()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.connected.add(channel.id());</span><br><span class="line">                        <span class="keyword">this</span>.sensors.connectionCreated.record();</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                        log.debug(<span class="string">"Created socket with SO_RCVBUF = &#123;&#125;, SO_SNDBUF = &#123;&#125;, SO_TIMEOUT = &#123;&#125; to node &#123;&#125;"</span>,</span><br><span class="line">                                socketChannel.socket().getReceiveBufferSize(),</span><br><span class="line">                                socketChannel.socket().getSendBufferSize(),</span><br><span class="line">                                socketChannel.socket().getSoTimeout(),</span><br><span class="line">                                channel.id());</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* if channel is not ready finish prepare */</span></span><br><span class="line">                <span class="keyword">if</span> (channel.isConnected() &amp;&amp; !channel.ready())</span><br><span class="line">                    channel.prepare();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* if channel is ready read from any connections that have readable data */</span></span><br><span class="line">                <span class="comment">//从底层channel读，按照包来读</span></span><br><span class="line">                <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;</span><br><span class="line">                    NetworkReceive networkReceive;</span><br><span class="line">                    <span class="keyword">while</span> ((networkReceive = channel.read()) != <span class="keyword">null</span>)</span><br><span class="line">                        addToStagedReceives(channel, networkReceive);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* if channel is ready write to any sockets that have space in their buffer and for which we have data */</span></span><br><span class="line">                <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                    Send send = channel.write();</span><br><span class="line">                    <span class="keyword">if</span> (send != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.completedSends.add(send);</span><br><span class="line">                        <span class="keyword">this</span>.sensors.recordBytesSent(channel.id(), send.size());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* cancel any defunct sockets */</span></span><br><span class="line">                <span class="keyword">if</span> (!key.isValid())</span><br><span class="line">                    close(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                String desc = channel.socketDescription();</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException)</span><br><span class="line">                    log.debug(<span class="string">"Connection with &#123;&#125; disconnected"</span>, desc, e);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    log.warn(<span class="string">"Unexpected error from &#123;&#125;; closing connection"</span>, desc, e);</span><br><span class="line">                close(channel, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要看后面的两个逻辑读和写，前面的似乎是客户端的逻辑，因为这个类是公用的，目前还不确定.<br>先看读逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)</span><br><span class="line">NetworkReceive networkReceive;</span><br><span class="line">                   <span class="keyword">while</span> ((networkReceive = channel.read()) != <span class="keyword">null</span>)</span><br><span class="line">                       addToStagedReceives(channel, networkReceive);</span><br><span class="line">   <span class="comment">//addToStagedReceives方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToStagedReceives</span><span class="params">(KafkaChannel channel, NetworkReceive receive)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!stagedReceives.containsKey(channel))</span><br><span class="line">           stagedReceives.put(channel, <span class="keyword">new</span> ArrayDeque&lt;NetworkReceive&gt;());</span><br><span class="line"></span><br><span class="line">       Deque&lt;NetworkReceive&gt; deque = stagedReceives.get(channel);</span><br><span class="line">       deque.add(receive);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到如果channel已经就绪，同时可读，也没有未处理的请求，就把数据读出来，放到stagedReceives这个队列里面去.看到这个while似乎请求包可以有多个，但是前面我们已经看到了，应答包只能有1个，这个有点奇怪了。这里有一篇2015年1月的<a href="http://blog.csdn.net/jewes/article/details/42403721" target="_blank" rel="noopener">文章</a>也是分析kafka网络层的，那个时候对于channel，read还只能read一个包.这里需要对照客户端的代码一起看，看一下是不是客户端也用了send这个结构，只能send一个。</p>
<p>channel.read方法读取数据是标准的按包读，先读4个字节来确定包长度，然后开对应大小的buffer把剩下的读进来。<br>具体的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NetworkReceive <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       NetworkReceive result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (receive == <span class="keyword">null</span>) &#123;</span><br><span class="line">           receive = <span class="keyword">new</span> NetworkReceive(maxReceiveSize, id);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       receive(receive);</span><br><span class="line">       <span class="keyword">if</span> (receive.complete()) &#123;</span><br><span class="line">           receive.payload().rewind();</span><br><span class="line">           result = receive;</span><br><span class="line">           receive = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">receive</span><span class="params">(NetworkReceive receive)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> receive.readFrom(transportLayer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readFrom</span><span class="params">(ScatteringByteChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> readFromReadableChannel(channel);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Need a method to read from ReadableByteChannel because BlockingChannel requires read with timeout</span></span><br><span class="line">   <span class="comment">// See: http://stackoverflow.com/questions/2866557/timeout-for-socketchannel-doesnt-work</span></span><br><span class="line">   <span class="comment">// This can go away after we get rid of BlockingChannel</span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readFromReadableChannel</span><span class="params">(ReadableByteChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (size.hasRemaining()) &#123;</span><br><span class="line">           <span class="keyword">int</span> bytesRead = channel.read(size); <span class="comment">//这个size是一个长度为4的bytebuffer</span></span><br><span class="line">           <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">           read += bytesRead;</span><br><span class="line">           <span class="keyword">if</span> (!size.hasRemaining()) &#123;</span><br><span class="line">               size.rewind();</span><br><span class="line">               <span class="keyword">int</span> receiveSize = size.getInt();</span><br><span class="line">               <span class="keyword">if</span> (receiveSize &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InvalidReceiveException(<span class="string">"Invalid receive (size = "</span> + receiveSize + <span class="string">")"</span>);</span><br><span class="line">               <span class="keyword">if</span> (maxSize != UNLIMITED &amp;&amp; receiveSize &gt; maxSize)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InvalidReceiveException(<span class="string">"Invalid receive (size = "</span> + receiveSize + <span class="string">" larger than "</span> + maxSize + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.buffer = ByteBuffer.allocate(receiveSize);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> bytesRead = channel.read(buffer);</span><br><span class="line">           <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">           read += bytesRead;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> read;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> !size.hasRemaining() &amp;&amp; !buffer.hasRemaining();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到如果网络层数据不完整，就是size或者buffer有remaining的时候，就返回了一个空的result，等下一次poll的时候再来。</p>
<p>下面的写方法就是直接把channel上持有的send发出去，然后放入completedSends队列里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//in selector poll</span></span><br><span class="line"> <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                    Send send = channel.write();</span><br><span class="line">                    <span class="keyword">if</span> (send != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.completedSends.add(send);</span><br><span class="line">                        <span class="keyword">this</span>.sensors.recordBytesSent(channel.id(), send.size());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> <span class="comment">//channel.write</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Send <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Send result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (send != <span class="keyword">null</span> &amp;&amp; send(send)) &#123;</span><br><span class="line">            result = send;</span><br><span class="line">            send = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">(Send send)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        send.writeTo(transportLayer);</span><br><span class="line">        <span class="keyword">if</span> (send.completed())</span><br><span class="line">            transportLayer.removeInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> send.completed();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>返回到poll方法，在pollSelectionKeys之后会通过 addToCompletedReceives方法把stagedReceive放到CompletedReceives里面去。注意这两个结构都是kafka自己包装的Selector类里面的属性（这个类里面有个nio的Selector）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToCompletedReceives</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.stagedReceives.isEmpty()) &#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt;&gt; iter = <span class="keyword">this</span>.stagedReceives.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt; entry = iter.next();</span><br><span class="line">            KafkaChannel channel = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (!channel.isMute()) &#123;</span><br><span class="line">                Deque&lt;NetworkReceive&gt; deque = entry.getValue();</span><br><span class="line">                addToCompletedReceives(channel, deque);</span><br><span class="line">                <span class="keyword">if</span> (deque.isEmpty())</span><br><span class="line">                    iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToCompletedReceives</span><span class="params">(KafkaChannel channel, Deque&lt;NetworkReceive&gt; stagedDeque)</span> </span>&#123;</span><br><span class="line">    NetworkReceive networkReceive = stagedDeque.poll();</span><br><span class="line">    <span class="keyword">this</span>.completedReceives.add(networkReceive);</span><br><span class="line">    <span class="keyword">this</span>.sensors.recordBytesReceived(channel.id(), networkReceive.payload().limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理收到的结果-processCompletedReceives"><a href="#处理收到的结果-processCompletedReceives" class="headerlink" title="处理收到的结果 processCompletedReceives"></a>处理收到的结果 processCompletedReceives</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//processor.processCompletedReceives</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedReceives</span></span>() &#123;</span><br><span class="line">    selector.completedReceives.asScala.foreach &#123; receive =&gt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> openChannel = selector.channel(receive.source)</span><br><span class="line">        <span class="keyword">val</span> session = &#123;</span><br><span class="line">          <span class="comment">// Only methods that are safe to call on a disconnected channel should be invoked on 'channel'.</span></span><br><span class="line">          <span class="keyword">val</span> channel = <span class="keyword">if</span> (openChannel != <span class="literal">null</span>) openChannel <span class="keyword">else</span> selector.closingChannel(receive.source)</span><br><span class="line">          <span class="type">RequestChannel</span>.<span class="type">Session</span>(<span class="keyword">new</span> <span class="type">KafkaPrincipal</span>(<span class="type">KafkaPrincipal</span>.<span class="type">USER_TYPE</span>, channel.principal.getName), channel.socketAddress)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> req = <span class="type">RequestChannel</span>.<span class="type">Request</span>(processor = id, connectionId = receive.source, session = session,</span><br><span class="line">          buffer = receive.payload, startTimeMs = time.milliseconds, listenerName = listenerName,</span><br><span class="line">          securityProtocol = securityProtocol)</span><br><span class="line">        requestChannel.sendRequest(req)</span><br><span class="line">        selector.mute(receive.source)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e @ (_: <span class="type">InvalidRequestException</span> | _: <span class="type">SchemaException</span>) =&gt;</span><br><span class="line">          <span class="comment">// note that even though we got an exception, we can assume that receive.source is valid. Issues with constructing a valid receive object were handled earlier</span></span><br><span class="line">          error(<span class="string">s"Closing socket for <span class="subst">$&#123;receive.source&#125;</span> because of error"</span>, e)</span><br><span class="line">          close(selector, receive.source)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是把之前selector读到的请求包装城session对象和request对象，放入一开始说的requestChannel队列里面。然后把对应的channel mute掉，就是transportLayer.removeInterestOps(SelectionKey.OP_READ);</p>
<h3 id="处理已经发送的请求-processCompletedSends"><a href="#处理已经发送的请求-processCompletedSends" class="headerlink" title="处理已经发送的请求 processCompletedSends"></a>处理已经发送的请求 processCompletedSends</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//processor.processCompletedSends</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedSends</span></span>() &#123;</span><br><span class="line">    selector.completedSends.asScala.foreach &#123; send =&gt;</span><br><span class="line">      <span class="keyword">val</span> resp = inflightResponses.remove(send.destination).getOrElse &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"Send for <span class="subst">$&#123;send.destination&#125;</span> completed, but not in `inflightResponses`"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      resp.request.updateRequestMetrics()</span><br><span class="line">      selector.unmute(send.destination)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是根据processor.poll方法中已经成功发送应答列表，把在ProcessNewResponses这一步放入的inflightResponses的response给remove掉，然后unmute，即使把OP_READ给加回来。</p>
<h3 id="处理已经断开的连接processDisconnected"><a href="#处理已经断开的连接processDisconnected" class="headerlink" title="处理已经断开的连接processDisconnected"></a>处理已经断开的连接processDisconnected</h3><p>这个方法就是做一些清理工作，把还没发送的响应给remove掉。connectionQuotas减掉。其中selector的disconnected队列会在客户端发起close，或者客户端超时，或者poll方法在清理过期连接等等情况的时候被加入。<br>selector的close会先把channel给close掉，再放入这个队列<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//processor.processDisconnected</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processDisconnected</span></span>() &#123;</span><br><span class="line">    selector.disconnected.asScala.foreach &#123; connectionId =&gt;</span><br><span class="line">      <span class="keyword">val</span> remoteHost = <span class="type">ConnectionId</span>.fromString(connectionId).getOrElse &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"connectionId has unexpected format: <span class="subst">$connectionId</span>"</span>)</span><br><span class="line">      &#125;.remoteHost</span><br><span class="line">      inflightResponses.remove(connectionId).foreach(_.request.updateRequestMetrics())</span><br><span class="line">      <span class="comment">// the channel has been closed by the selector but the quotas still need to be updated</span></span><br><span class="line">      connectionQuotas.dec(<span class="type">InetAddress</span>.getByName(remoteHost))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//selector.doClose</span></span><br><span class="line">   <span class="keyword">private</span> void doClose(<span class="type">KafkaChannel</span> channel, boolean notifyDisconnect) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</span><br><span class="line">            log.error(<span class="string">"Exception closing connection to node &#123;&#125;:"</span>, channel.id(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sensors.connectionClosed.record();</span><br><span class="line">        <span class="keyword">this</span>.stagedReceives.remove(channel);</span><br><span class="line">        <span class="keyword">if</span> (notifyDisconnect)</span><br><span class="line">            <span class="keyword">this</span>.disconnected.add(channel.id());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><span id="kafka_network_1_conclution"></span></p>
<h3 id="总结一下整个流程："><a href="#总结一下整个流程：" class="headerlink" title="总结一下整个流程："></a>总结一下整个流程：</h3><p>服务器通过一个Acceptor来接受请求，多个Processor来处理读写。Processor里面维护这kafka封装过的selector。Selector维护着注册在上面的channel，并且处理对于channel的实际读写。</p>
<p>Acepptor把接受到的连接交给Processor的newConnection队列，Processor拿到连接并注册到自己的Selector上。</p>
<p>Processor通过requestChannel（里面包含了请求与响应2个队列）拿到自己要处理的响应，通过selector发出，selector这时候只是找到对应的Channel并设置send属性，并打开OP_WRITE，并记录到inflightResponses队列。</p>
<p>然后processor通过poll方法，实际调用selector的poll方法把客户端的请求读出来放入CompletedReceives队列，把对客户端的响应写到客户端,并移除OP_WRITE，放入completedSends队列。</p>
<p>接着Processor把从CompletedReceives读到的请求构造成request，扔到requestChannel队列里面去，然后移除OP_READ（读完了，请求还没处理，不能在读了）</p>
<p>然后Processor从completedSends队列连取出之前成功发出的响应，把对应inflightResponses移除，同时打开OP_READ。（写好了响应，可以接着接受请求了）</p>
<p>最后处理连接断开，把对应inflightResponses里面的响应移除。</p>
<p>可以看到Selector自己维护着channels,completedSends，completedReceives，processor从selector连获取这些信息，而且发送与接受实际完成者都是Seletor。</p>
<p>从性能上来说，selector有多个，可以增加读写性能，因为建立连接远小于在连接上读写数据。</p>
<p>接下来会写一下接受到的请求如何与上层API交互。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LongYuBo</p>
              <p class="site-description motion-element" itemprop="description">Backend Developer</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          
        </div>
      </section>

  

      

      

    </div>

    <div class="sidebar-inner">
      
     <iframe  style="margin-left:-8px" frameborder=0 width="240px" height="300px"    scrolling=no src="https://tb.longyb.com/sliding.html"></iframe> 
      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LongYuBo</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>




        








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1274971050&web_id=1274971050" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.bootcss.com/velocity/1.3.1/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.bootcss.com/velocity/1.3.1/velocity.ui.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  

  
    <script id="dsq-count-scr" src="https://longyb.disqus.com/count.js" async></script>
  

  












  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
